# ARM/Thumb统一汇编语言指令

本章概要介绍ARM/Thumb汇编语言，并不详细列举每一个指令的细节，对每一条指令的描述可以参考附录A指令概述。

指令可以大致分为如下的几类：

* 数据处理器运算（ALU运算比如ADD）。
* 内存访问（加载和存储数据到内存）
* 控制流（用于循环，goto，条件码和其他的程序流控制）
* 系统（协处理器，调试，模式修改等）

本章接下来的内容会逐一介绍上述每一类。在这之前，先看一些不同指令类共有的基础知识。

###5.1 指令基础###

有一些功能对指令集的所有指令都是共有的，下面介绍这些具有共性的内容。

#####5.1.1 常数和立即数#####



#####5.1.2 条件执行#####


#####5.1.3 状态标志和条件码#####

###5.2 数据处理运算###

在算术运算中，注意移动运算的MOV和MVN仅需要一个操作数（当作操作数2，可以获得最大的灵活性，如下节所述）。RSB作一个相反的接反，即用第二个操作数减第一个操作数。之所以需要这个指令是因为第一个操作数不灵活，它只能是寄存器。如果写表达式`R0=100-R1`的汇编代码时必须使用`RSB R0, R1, #100`，`SUB R1, #100, R1`是一条非法指令。运算ADC和SBC执行带进位的加法和减法。使用这两个指令可以实现大于32位数字的算术运算。

逻辑运算和对应的C操作符一样。注意在ARM汇编中使用ORR而不是OR做或运算，之所以使用ORR是因为原始的ARM指令集中所有的数据处理运算都是有三个字母缩写。BIC指令将一个寄存器与操作数2的相反数做AND运算。例如，如果想要清掉寄存器R0的位11，可以使用指令`BIC R0, R0, #0x800`。

第二个操作数0x800只有位11的值被设置为1，其他的位都是0。BIC指令将它取反，即将除了位11以外的值都设置为1。将这个与寄存器R0中的数做AND操作则会清掉位11的值，即设置为0，然后将结果再写回R0。

比较和测试指令修改CPSR（没有其他的副作用）。

#####5.2.1 操作数2和快速移位#####

所有数据处理运算的第一个操作数必须总是寄存器。第二个操作数则更加灵活，既可以是立即数（#x），寄存器（Rm），或用立即数/寄存器进行移位的寄存器`Rm, shift #x`或`Rm, shift Rs`。一共有五种移位运算：左移位（LSL），逻辑右移位（LSR），算术右移位（ASR），循环右移位（ROR）和循环右移位扩展（RRX）。

右移位会在寄存器的顶部空出位置，这种情况下需要区分逻辑移位和算术移位。逻辑移位在最高位插入0，而算术移位则使用符号位（寄存器的第31位）填充空出来的位。因此ASR运算需要使用一个有符号值，LSR使用无符号值。左移运算没有这些区别，总是在最低有效位插入0。

因此，与其他汇编语言不同，ARM汇编语言不要求显示的移位指令。例如MOV指令可以用于移位或循环移位，`R0=R1>>2`可以通过`MOV R0, R1, LSR #2`实现。同样地也可以将移位与ADD，SUB或其他的指令结合使用，例如将R0乘以5可以使用如下指令实现。

```
ADD R0, R0, R0, LSL #2
```

左移n位等价于乘以`2^n`，因此这句代码可以非常快地完成`R0=R0+(4x40)`。右移位提供了对应的除法运算，尽管ASR循环移位负数与C语言中的除法不同。

除了乘法和除法，其他的更常用的移位操作用于数组索引。例如R1指向一个int数组的基地址元素，R2是指向数组中第n个元素的索引。带有计算`R1+(R2x4)`的加载指令就可以使用计算的地址值获取到对应数组元素值。例5-3给出了在ARM指令中使用的不同操作数2类型。

<div align="center">例5-3 ARM指令中的各种操作数2类型</div>
```
add 	R0, R1, #1			@ R0 = R2 + 1
add 	R0, R1, R2			@ R0 = R1 + R2
add		R0, R1, R2, LSL #4	@ R0 = R1 + R2 << #4
add		R0, R1, R2, LSL R3	@ R0 = R1 + R2 << R3
```

#####5.2.2 乘法运算#####


