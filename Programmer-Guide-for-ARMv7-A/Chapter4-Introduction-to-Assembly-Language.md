# 汇编语言介绍

汇编语言是一个低级编程语言。通常，汇编语言指令（助记符）和内核实际执行的二进制操作码具有一一对应的关系。

许多程序员在应用级编写代码，很少会使用汇编语言编写代码。但是，汇编编码知识在一些情况下非常有用，比如需要高度优化的代码的地方，编写编译器时，或者底层无法直接使用C语言编写的功能。再比如在进行操作系统开发时，引导代码，设备驱动等都需要一部分汇编代码。最后，在调试C程序时或者立即汇编指令与C语句的映射关系时，熟练阅读汇编代码也会非常有帮助。

如果想要阅读更多关于ARM汇编语言的细节信息可以参考ARM编译器工具链汇编参考或ARM架构参考文档等资料。

###4.1 与其他汇编语言对比###

ARM处理器是精简指令集（RISC）处理器。复杂指令集（CISC）处理器有非常丰富的指令集，比如X86，它可以在一条指令中完成非常复杂的工作。这样的处理器通常有大量的内部逻辑，这些内部逻辑将机器指令解码成衣系列内部运算（微操作）。与此相反，RISC架构只有非常少的通用指令，因此只需要很少的晶体管就能完成运行，这使得硅片设计比较简单，价格低廉，也更加节能。与其他的RISC架构类似，ARM内核有大量的通用寄存器，很多指令都是在一个指令周期内完成。ARM使用简单的寻址模式，所有的加载/存储地址都是有寄存器和指令域确定。

ARMv7-A架构有基本的数据处理指令，内核可以执行算术运算（例如ADD）和逻辑位操作（比如AND）。为了支持循环和条件语句，部分指令可以将程序执行从程序的一部分转移到另外一部分，即实现跳转。架构也具有读取和写入外存的指令。

ARM指令集具有简洁，合理和高效的特性。它具有一些其他处理器不具备的功能，当然了它也会缺少一些其他处理器上的功能。例如，ARM指令不可以直接在内存上执行数据运算。为了将内存某个位置的值加一，这个值必须先加载到ARM寄存器中，将寄存器的值加一，然后使用第三条指令将数据写回内存更新原来的值。指令集结构（ISA）包括很多指令，将移位和算术或逻辑运算结合的指令，优化程序循环的带有自增和自减的寻址模式，为了更有效访问栈或堆的加载或存储多条指令的指令，再加上块拷贝指令和几乎所有指令都有条件执行。

与X86类似（但是与68K不同），ARM指令通常是有两个或三个操作数的格式，第一个操作数通常指定结果目的操作数。加载多个数据和存储指令是个例外例子。于此相反，68K则是将目的操作数放在最后位置。在ARM指令中，那个寄存器可以用作操作数通常没有限制。例4-1和例4-2给出了不同汇编语言之间相同功能汇编语句的对比。

<div align="center">例4-1 将寄存器的值加100的指令</div>
```
x86: add 	eax, #100
68K: ADD	#100, D0
ARM: add	r0, r0, 100
```

<div align="center">例4-2 从寄存器指针中加载一个32位数到寄存器中</div>
```
x86: mov	eax, DWORD PTR [ebx]
68K: MOV.L	(A0), D0
ARM: ldr	r0, [r1]
```

###4.2 ARM指令集###

ARMv7架构是一种32位的处理器架构，它也是一种加载/存储架构，即数据处理指令仅对通用寄存器中的数据进行操作。仅加载和存储指令访问内存。通用寄存器也都是32位。整本书中，当指定word时意思就是32位数；那么双字就是64位了，半字就是16位宽。

尽管ARMv7架构是32位的体系结构，单个处理器的实现没有必要将所有的块或互联都设置为32位。例如，指令预取和数据访问可以是64位，甚至更宽的路径。

大多数ARM处理器支持两个或甚至三个不同的指令集，然后一些处理器（比如Cortex-M3处理器）实际上连原始的ARM指令集也不支持。ARM处理器可以使用至少两种指令集，如下所述：

**ARM（32位指令）**：最初的原始ARM指令集。

**Thumb**：Thumb指令集第一次引入是在ARM7TDMI处理器中，并且只包含有16位的指令。Thumb指令集以一点性能作为代价换取更小的程序尺寸（在更小的嵌入式系统中，内存占用是主要考虑的问题）。最新的处理器，包括Cortex-A系列处理器，开始支持Thumb-2技术。Thumb-2技术扩展了Thum指令集，提供了16位和32位指令混合使用的技术。Thumb-2技术让程序具有Thumb和ARM双重优点，一方面程序执行性能类似于ARM指令集，另一方面代码尺寸类似于Thumb指令集。因为兼具尺寸和性能优势，越来越多代码都编译或汇编成使用Thumb-2技术的代码。

在老版本的ARM处理器中，系统总是同时包含为ARM状态编译的代码和位Thumb状态编译的代码。ARM代码是32位指令，具有更强劲的性能，执行某些特定的任务要求更少的指令，对于要求高性能的系统模块更倾向于使用它。同时ARM代码也被用于异常处理代码，主要是因为在ARM7或ARM9系列处理器上异常不能在Thumb状态下处理。

Thumb代码使用16位指令，与ARM代码对比，在执行一些任务时需要更多指令。Thumb代码在指令中只能编码非常小的常数值，相对转移的偏移值也更小，参考第五章转移中的内容。ARM指令的相对跳转的范围大约是+/-32MB，Thumb-2的相对跳转范围大约是+/-16MB。Thumb指令使用16位的指令，那么它的相对跳转的范围更加受限，条件跳转范围大约是向前/向后的256字节，非条件转移大概是向前/向后的2048字节。

然而，因为Thumb指令仅仅只有半个字的宽度，程序通常比ARM代码等价程序尺寸小三分之一。Thumb指令因此主要用于需要紧凑代码的地方，以降低内存需求。当处理器直接连接到窄接口内存（16位），没有Cache可用时，Thumb代码的表现要胜过ARM代码。这种情况下一条Thumb指令可以在一个时钟周期内取得，但是每一条32位的ARM指令的取指令则需要两个时钟周期。

当执行Thumb指令是，PC值的读取按照当前指令地址加4。只有16位Thumb指令可以直接修改PC，比如MOV和ADD指令。写入PC的值也是通过忽略最低位（将最低位当作0）来强制实现半字对齐。

在ARMCC编译器中，选项`--thumb`或`-arm`（默认值）可以用来选择编译时使用什么指令集。在运行时，程序可以通过转移指令在两个指令集之间跳转。

当前使用的指令集是由CPSR中的T位标识，内核执行在ARM状态时T=0，执行在Thumb状态时T=1。代码必须显示地编译或汇编为其中一种状态，或者ARM代码或者Thumb代码。在两个指令集之间切换也需要使用特别的指令显示切换。调用编译为不同当前状态的函数称为interworking，在混合调用中会详细介绍。

对于Thumb汇编代码，可以选择16位指令编码或32位指令编码，默认情况下是使用16位版本生成代码。`.W`（32位）和`.N`（16位）宽度指示符用于强制特定编码（如果这个编码存在），例如：

```
BCS.W label  ; 强制编译为32位指令，即使是短转移
B.N label    ; 如果label在16位指令范围之外则出错
```

###4.3 GNU汇编器介绍###

GNU汇编器是GNU工具集的组成部分，用于将汇编语言源码转化成位二进制目标文件。汇编器完整的文档在GNU汇编器参考手册中，可以在线找到[http://sourceware.org/binutils/docs/as/index.html ](http://sourceware.org/binutils/docs/as/index.html )，或者如果你安装了GNU工具集，在`gnutools/doc`目录下可以找到。GNU汇编器文档也可以在Ubuntu的`/gcc-doc/`包中找到。

本节下面的内容是对GNU汇编器的简单介绍，为了强调GNU汇编器和标准ARM汇编语言在语法上的区别；同时也为了让开发者可以有足够的信息能够开始使用这个工具。

GNU工具组件的名字会有前缀表明选择的目标架构以及操作系统。例如`arm-none-eabi-gcc`，它可能用于bare metal系统，使用ARM EABI。

#####4.3.1 调用GNU汇编器#####

按照如下命令运行`arm-none-eabi-as`程序可以将ARM汇编语言源文件汇编为目标文件。

```
arm-none-eabi-as -g -o filename.o filename.s
```

选项`-g`要求汇编器在输出文件中包含调试信息。

当所有的源文件汇编成为二进制目标文件（带有扩展名`.o`），使用GNU链接器创建最终的ELF格式的可执文件。按照如下的命令执行：

```
arm-none-eabi-ld -o filename.elf filename.o
```

对于更加复杂的程序会有很多分离的源文件，更加通用的做法是使用一个工具比如make来控制编译过程。可以使用`arm-none-eabi-gdb`或`arm-none-eabi-insight`调试器在目标机上运行执行文件，作为真实目标内核的模拟。

#####4.3.2 GNU汇编器语法#####

GNU汇编器可以用于不同的处理器架构，并不是ARM专属。这意味着他的语法有一些与ARM汇编器不同，比如ARM工具链。GNU汇编器对于它支持的处理器架构使用相同的汇编语法。

汇编语言源文件由一系列的语句组成，每一行一条语句。每一条语句有三个可选部分，按照如下的形式排序：

```
label: instruction  @comment
```

label（标号）用来表示这条指令的地址，这个值可以用于转移指令或加载存储指令的目标。标号可以由一个字母，后面跟着一串字符或数字字符，最后由冒号标识结束。

instruction（指令）即可是ARM汇编指令，也可以是汇编命令。汇编命令是伪指令，用于编译器完成一些工作。汇编命令在其他地方也需要，比如控制代码区段，对齐或创建程序用数据等。

在一行中`@`符号后面的任何内容都当作注释，都会被忽略（除非它在一个字符串中）。C风格的注释符号`/* */`也可以使用。

如果在源码中没有显示提供代码入口点，在链接时可以在命令行上加以指定。

#####4.3.3 段#####

一个带有代码的可执行程序至少会有一个段，通常这个段都会叫做`.text`，数据一般包含在`.data`段。

使用相同名字的汇编命令用来指定两个段应该包含汇编命令后面源码文件中的内容。可执行代码应该出现在`.text`段中，可读数据或可写数据应该出现在`.data`段中。只读的常数可以放在`.rodata`段，初始化为零的数据应该放在`.bss`段中。BSS段定义了未初始化静态数据的空间。

#####4.3.4 汇编命令#####

这一部分是GNU工具与其他的汇编器不同的关键部分。

所有的汇编命令都是以`.`开始，GNU文档中所有的汇编命令的详细列表。这里，我们给出一个常用的命令的子集：

**.align**: 这个命令使得汇编器在数据段用0补齐二进制，在代码中使用NOP指令补齐段，以确保接下来的位置会是字边界。`.align n`在ARM内核上给出2^n字节的堆砌。



#####4.3.5 表达式#####

#####4.3.6 GNU工具命名约定#####

###4.4 ARM工具汇编语言###

#####4.4.1 ARM汇编器语法#####

#####4.4.2 标号#####

#####4.4.3 汇编器命令#####

###4.5 ARM/Thumb混合使用###

###4.6 识别汇编代码###

###4.7 ARMv8-A兼容###


By Andy @2018-05-15 10:05:23