# 汇编语言介绍

汇编语言是一个低级编程语言。通常，汇编语言指令（助记符）和内核实际执行的二进制操作码具有一一对应的关系。

许多程序员在应用级编写代码，很少会使用汇编语言编写代码。但是，汇编编码知识在一些情况下非常有用，比如需要高度优化的代码的地方，编写编译器时，或者底层无法直接使用C语言编写的功能。再比如在进行操作系统开发时，引导代码，设备驱动等都需要一部分汇编代码。最后，在调试C程序时或者立即汇编指令与C语句的映射关系时，熟练阅读汇编代码也会非常有帮助。

如果想要阅读更多关于ARM汇编语言的细节信息可以参考ARM编译器工具链汇编参考或ARM架构参考文档等资料。

###4.1 与其他汇编语言对比###

ARM处理器是精简指令集（RISC）处理器。复杂指令集（CISC）处理器有非常丰富的指令集，比如X86，它可以在一条指令中完成非常复杂的工作。这样的处理器通常有大量的内部逻辑，这些内部逻辑将机器指令解码成衣系列内部运算（微操作）。与此相反，RISC架构只有非常少的通用指令，因此只需要很少的晶体管就能完成运行，这使得硅片设计比较简单，价格低廉，也更加节能。与其他的RISC架构类似，ARM内核有大量的通用寄存器，很多指令都是在一个指令周期内完成。ARM使用简单的寻址模式，所有的加载/存储地址都是有寄存器和指令域确定。

ARMv7-A架构有基本的数据处理指令，使得内核可以执行算术运算（例如ADD）和逻辑位操作（比如AND）。为了支持循环和条件语句，部分指令可以将程序执行从程序的一部分转移到另外一部分，即实现跳转。架构也具有读取和写入外存的指令。

ARM指令集具有简洁，合理和高效的特性。它具有一些其他处理器不具备的功能，当然了它也会缺少一些其他处理器上的功能。例如，ARM指令不可以直接在内存上执行数据运算。为了将内存某个位置的值加一，这个值必须先加载到ARM寄存器中，将寄存器的值加一，然后使用第三条指令将数据写回内存更新原来的值。指令集结构（ISA）包括很多指令，将移位和算术或逻辑运算结合的指令，优化程序循环的带有自增和自减的寻址模式，为了更有效访问栈或堆的加载或存储多条指令的指令，再加上块拷贝指令和几乎所有指令都有条件执行。

与X86类似（但是与68K不同），ARM指令通常是有两个或三个操作数的格式，第一个操作数通常指定结果目的操作数。加载多个数据和存储指令是个例外例子。于此相反，68K则是将目的操作数放在最后位置。在ARM指令中，那个寄存器可以用作操作数通常没有限制。例4-1和例4-2给出了不同汇编语言之间的不同。

<div align="center">例4-1 将寄存器的值加100的指令</div>
```
x86: add 	eax, #100
68K: ADD	#100, D0
ARM: add	r0, r0, 100
```

<div align="center">例4-2 从寄存器指针中加载一个32位数到寄存器中</div>
```
x86: mov	eax, DWORD PTR [ebx]
68K: MOV.L	(A0), D0
ARM: ldr	r0, [r1]
```

###4.2 ARM指令集###


###4.3 GNU汇编器介绍###


#####4.3.1 调用GNU汇编器#####

#####4.3.2 GNU汇编器语法#####

#####4.3.3 段#####

#####4.3.4 汇编命令#####

#####4.3.5 表达式#####

#####4.3.6 GNU工具命名约定#####

###4.4 ARM工具汇编语言###

#####4.4.1 ARM汇编器语法#####

#####4.4.2 标号#####

#####4.4.3 汇编器命令#####

###4.5 ARM/Thumb混合使用###

###4.6 识别汇编代码###

###4.7 ARMv8-A兼容###


By Andy @2018-05-15 10:05:23